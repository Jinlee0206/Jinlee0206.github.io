---
layout: post
title:  "[기술 면접] 용어 정리"
excerpt : "개발, 면접"
categories: develop
tags: devlog csharp unity cpp unreal

toc: true

date:   2024-03-06
last_modified_at: 2024-08-25
comments : true
---
> <span style="font-size: 80%"> **출처** </span>      
>> <span style="font-size: 80%"> [꾸준히 하나씩 블로그 링크](https://coldpresso.tistory.com/18)</span>

<!--more-->

* this unordered seed list will be replaced by the toc
{:toc}

# C++

## 객체

현실 세계에서 실재하는 모든 대상을 추상화하여 변수와 함수로 구성한 프로그래밍적 개념

값을 저장하고 사용할 수 있는 메모리 조각   
이름있는 객체 = 변수

## 객체지향 프로그래밍

함수를 작성하는데 더 초점을 맞추기 보단 명확하게 정의된 동작 세트가 있는 객체를 정의하는 데 더 중점을 두는 패러다임

프로그램을 수많은 `객체`라는 기본 단위로 나누고 이 객체들의 상호작용으로 서술하는 방식

**객체지향 프로그래밍의 4가지 특징**

1) 추상화 : 대상의 본질적인 특성을 추출하여 객체로 표현하는 것.

2) 상속 : 기존에 있는 클래스를 활용하여 객체를 추상화 및 구현, 코드 재사용성 증가

3) 다형성 : 메서드 오버라이딩 및 오버로딩으로 상황에 따라 여러 기능 구현 / 하위 클래스는 상위 클래스 타입으로 참조 가능 / 코드 재사용성 증가

4) 캡슐화 : 외부로부터 데이터 보호, 은닉 / 유지보수의 용이성 증가

**객체지향 프로그래밍 설계 5원칙**

**SOLID 원칙** 
- SRP(Single Responsibility Principle, 단일책임원칙)
  - 하나의 클래스는 하나의 책임(기능)만 가져야한다.
  - 코드 가독성, 유지보수의 용이성
- OCP(Open Closed Principle, 개방폐쇄원칙)
  - 클래스는 확장에 열려있고, 변경에 닫혀있어야 한다.
  - 다형성과 상속에 대한 강조 -> 코드 재사용성, 유지보수의 용이성 극대화
- LSP(Liskov Substitution Principle, 리스코프 치환 원칙)
  - 하위 클래스는 언제나 상위 클래스로 교체될 수 있어야 한다.
  - 다형성에 대한 강조
- ISP(Interface Segregation Principle, 인터페이스 분리 원칙)
  - 클래스와 마찬가지로 인터페이스는 하나의 책임만 가져야한다.
  - 추상화에 대한 강조
- DIP(Dependency Inversion Principle, 의존 역전 원칙)
  - 변화하기 쉬운  것(구현체)보다는 변화하기 어려운 것(인터페이스, 추상 클래스)에 의존해야 한다.
  - 다형성에 대한 강조 -> 코드 재사용성 극대화

## 클래스

## 상속

## 가상함수

## 추상함수

## 인터페이스

## 코루틴

- 멀티스레드가 아닌 유니티에서 마치 멀티스레드처럼 보여 병렬적인 구조를 만드는 기능
- 시작과 끝이 항상 동일한 프레임에 발생해야하는 일반적인 메서드들과 달리 작업을 여러 프레임에 분산시킬수 있는 특별한 메서드
- 업데이트와는 달리 하나의 메서드 안에서 제어권을 유니티에 반환하고, 다음 프레임이나 특정 프레임부터 다시 진행할 수 있는 기능

# 알고리즘

## 정렬

### 퀵소트
1) 정렬 범위에서 피벗을 정한 후 피벗 왼쪽엔 피벗보다 작은 숫자를 피벗 오른쪽엔 큰 숫자들을 배치. 연산횟수는 N번   
2) 각각의 범위에 재귀적으로 다시 첫번째 단계 적용

$logN$번만에 모든 정렬범위를 1로 만들 수 있고, 각각 순환 호출 단계의 총 연산이 N이기 떄문에 정렬 성능은 NlogN

> 퀵소트는 정렬에 있어 추가적인 공간을 필요로 하지 않음.   

### 머지소트
1) 데이터의 중앙을 기준으로 데이터를 반으로 나눔    
2) 범위가 1이 될 때까지 재귀적으로 반복   
3) 나눠진 각각의 범위를 합치면서 정렬. 이 때 동일한 순환 호출 단계의 모든 연산 횟수는 O(N)

데이터를 정확히 반으로 나누기 때문에, 순환 호출의 깊이는 logN이 보장되며, 전체 성능은 NlogN

> 머지소트는 데이터 범위를 합칠 때 임시 배열에 해당 데이터를 담아야 하기 떄문에 O(N)의 추가 데이터가 필요

## 꼬리재귀
- 재귀 함수를 호출할 때 스택을 재사용하면서 메모리를 과도하게 사용하지 않도록 최적화하는 방법
- 재귀 호출이 끝난 후 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 재귀의 형태
  - 이를 이용하면 함수 호출이 반복되어 스택이 깊어지는 문제를 컴파일러가 선형으로 처리 하도록 알고리즘을 바꿔 스택을 재사용할 수 있게 됨


# Unreal Engine

## 직렬화 (Serialization)
> 오브젝트나 연결된 오브젝트의 묶음(오브젝트 그래프)을 바이트 스트림으로 변환하는 과정

복잡한 데이터를 일렬로 세우기 때문에 직렬화 라고 한다. 반대는 역직렬화(Deserialization)

- 현재 프로그래밍의 상태를 저장하고 필요할 때에 복원 가능. (게임의 저장)
- 현재 객체의 정보를 클립보드에 복사해서 다른 프로그램에 전송 가능.
- 네트워크를 통해 현재 프로그램의 상태를 다른 컴퓨터에 복원 가능. (멀티플레이어 게임)
- 데이터 압축, 암호화를 통해 데이터를 효율적이고 안전하게 보관 가능.
