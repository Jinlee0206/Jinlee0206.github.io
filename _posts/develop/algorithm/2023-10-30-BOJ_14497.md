---
layout: post
title:  "[C++] 백준(BOJ) - 14497 : 주난의 난"
excerpt : "구현, 브루트포스, 완전탐색, 그래프이론"
categories: develop
tags: cpp algorithm
toc: true

date: 2023-10-30
last_modified_at: 2023-10-30
---
> <span style="font-size: 80%">
인프런에 있는 큰돌님의 강의 10주완성 C++ 코딩테스트 | 알고리즘 코딩테스트를 듣고 정리한 필기입니다.</span>

<!--more-->

* this unordered seed list will be replaced by the toc
{:toc}

## 문제 

[백준(BOJ) - 14497 : 주난의 난(링크)](https://www.acmicpc.net/problem/14497)

## 알고리즘

  1. 완전탐색
  2. BFS
  3. 이중 큐를 이용한 BFS 완전 탐색

## 풀이
  1. 


## 코드  
```cpp
/// BOJ-14497 : 주난의 난
#include <bits/stdc++.h>
using namespace std;
#define y1 aaaa

const int dy[] = { -1,0,1,0 };
const int dx[] = { 0,1,0, -1 };

int n,m, y1, x1, y2, x2, cnt = 0;
char a[304][304];
int visited[304][304];

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);

    cin >> n >> m >> y1 >> x1 >> y2 >> x2;
    y1--, x1--, y2--, x2--;


    for (int i = 0; i < n; i++)
    {
        string str;
        cin >> str;
        for (int j = 0; j < str.size(); j++)
        {
            a[i][j] = str[j];
        }
    }

    queue<pair<int, int>> q;
    q.push({ y1, x1 });
    visited[y1][x1] = 1;

    while (a[y2][x2] != '0')
    {
        cnt++;
        queue<pair<int, int>> tq;

        while (q.size())
        {
            pair<int, int> tmp = q.front();
            q.pop();

            for (int i = 0; i < 4; i++)
            {
                int ny = tmp.first + dy[i];
                int nx = tmp.second + dx[i];

                if (ny < 0 || nx < 0 || ny >= n || nx >= m || visited[ny][nx]) continue;
                visited[ny][nx] = cnt;
                if (a[ny][nx] != '0')
                {
                    a[ny][nx] = '0';
                    tq.push({ ny,nx });
                }
                else q.push({ ny,nx });
            }
        }
        q = tq;
    }
    
    cout << visited[y2][x2] << '\n';

    return 0;
}
```

## 평가  
* 