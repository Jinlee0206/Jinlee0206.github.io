---
layout: post
title:  "[C++] 백준(BOJ) - 14469 : 소가 길을 건너간 이유 3"
excerpt : "라인스위핑"
categories: develop
tags: cpp algorithm
toc: true
comments : true

date: 2024-02-01
last_modified_at: 2024-02-01
---

* this unordered seed list will be replaced by the toc
{:toc}

## 문제 

[BOJ -  14469 : 소가 길을 건너간 이유 3(링크)](https://www.acmicpc.net/problem/14469)  

이웃 농장의 소가 길을 마구잡이로 건너는 것에 진절머리가 난 존은 극단의 결정을 내린다. 농장 둘레에 매우 큰 울타리를 짓는 것이다. 이렇게 하면 근처 농장 출신의 소가 들어올 일이 거의 없다. 이 일로 주변 소들이 분개하였다. 친구네 집에 놀러 갈 수 없을 뿐만 아니라, 매년 참가하던 국제 젖 짜기 올림피아드에도 올해는 참가할 수 없게 되었기 때문이다.

이웃 농장의 소 중 존의 농장에 방문할 수 있는 소가 조금 있긴 하지만, 그들도 안심할 수 있는 건 아니다. 존의 농장에 들어가는 문은 하나밖에 없고, 그 문을 통과하려면 감시관의 길고 긴 검문을 받아야 한다. 여러 마리의 소가 한 번에 들어가려고 하면 줄이 그 만큼 길어진다.

N마리의 소가 이 농장에 방문하러 왔다. 소가 도착한 시간과 검문받는 데 걸리는 시간은 소마다 다르다. (물론 같을 수도 있다.) 두 소가 동시에 검문을 받을 수는 없다. 예를 들어, 한 소가 5초에 도착했고 7초 동안 검문을 받으면, 8초에 도착한 그 다음 소는 12초까지 줄을 서야 검문을 받을 수 있다.

모든 소가 농장에 입장하려면 얼마나 걸리는 지 구해보자.

## 입력
첫 줄에 100 이하의 양의 정수 N이 주어진다. 다음 N줄에는 한 줄에 하나씩 소의 도착 시각과 검문 시간이 주어진다. 각각 1,000,000 이하의 양의 정수이다.

## 출력
모든 소가 농장에 입장하는 데 걸리는 최소 시간을 출력한다.


## 알고리즘
1. 라인 스위핑
2. 그리디
3. 정렬

## 풀이
1. 소가 처음 들어온 시점을 기준으로 오름차순 정렬
2. 먼저 들어온 소가 검문받는데 걸리는 시간과 현재 들어온 소가 도착한 시간 중 어떤 것이 더 큰지 비교해서 그것을 기준으로 검문 받는데 걸리는 시간을 붙여 나가며 라인 스위핑

## 코드
```cpp
// BOJ-14469 : 소가 길을 건너간 이유 3
#include<bits/stdc++.h>
using namespace std;

int n, res;
vector<pair<int, int>> v;

int main()
{
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int n;
	cin >> n;

	for (int i = 0; i < n; i++)
	{
		int a, b;
		cin >> a >> b;
		v.push_back({ a,b });
	}
	sort(v.begin(), v.end());

	res = v[0].first + v[0].second;

	for (int i = 1; i < n; i++)
	{
		res = max(res, v[i].first);
		res += v[i].second;
	}

	cout << res << "\n";
	return 0;
}
```

## 평가  
* 간단한 라인스위핑 문제
* 머릿속에서 그린 아이디어대로 차근차근 코드를 구성해 나가기